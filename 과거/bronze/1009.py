# 분산처리
# Bronze 2

# a, b를 a**b 형태로 나타냈을 때의 1의자리 (0이면 10 출력)

# 1. 시간초과
# T = int(input())    # 테스트 케이스 수
# for tc in range(T):
#     a, b = map(int, input().split())
#     n = str(a**b)[-1]   # a**b를 str으로 바꾸고 1의 자리만 남김
#     print(n) if n != 10 else print(10)  # 10이면 0 출력


# 2.
# 거듭제곱의 규칙 찾기
# import pprint
# arr = [[0 for i in range(9)]for i in range(9)]
# for i in range(1, 10):
#     for j in range(1, 10):
#         arr[i-1][j-1] = i**j
# pprint.pprint(arr)

# [[1, 1, 1, 1, 1, 1, 1, 1, 1],
#  [2, 4, 8, 16, 32, 64, 128, 256, 512],
#  [3, 9, 27, 81, 243, 729, 2187, 6561, 19683],
#  [4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144],
#  [5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125],
#  [6, 36, 216, 1296, 7776, 46656, 279936, 1679616, 10077696],
#  [7, 49, 343, 2401, 16807, 117649, 823543, 5764801, 40353607],
#  [8, 64, 512, 4096, 32768, 262144, 2097152, 16777216, 134217728],
#  [9, 81, 729, 6561, 59049, 531441, 4782969, 43046721, 387420489]]

# 1: 1 (1)
# 2: 2ㅡ4ㅡ8ㅡ6 (4)
# 3: 3ㅡ9ㅡ7ㅡ1 (4)
# 4: 4ㅡ6 (2)
# 5: 5 (1)
# 6: 6 (1)
# 7: 7ㅡ9ㅡ3ㅡ1(4)
# 8: 8ㅡ4ㅡ1ㅡ6 (4)
# 9: 9ㅡ1
# 0: 0 (1)

# 2, 3, 7, 8은 4개씩,
# 4, 9는 2개씩,
# 1, 5, 6, 9, 0 은 1개씩의
# 규칙성을 갖는다.
regu1 = [1, 5, 6]
regu = {
    2: [2, 4, 6, 8],
    3: [3, 9, 7, 1],
    4: [6, 4],
    7: [7, 9, 3, 1],
    8: [8, 4, 2, 6],
    9: [1, 9],
}

T = int(input())
for tc in range(T):
    a, b = map(int, input().split())
    a %= 10
    if a == 0:
        print(10)
    elif a in regu1:            # a가 1의 규칙성이면 그대로 출력
        print(a)
    elif a == 4 or a == 9:    # a가 2의 규칙성을 가지면 b % 2 - 1의 인덱스를 넣어 출력
        print(regu[a][b % 2])
    else:                     # a가 4의 규칙성을 가지면 b를 4로 나누고 1을 빼서 인덱스에 넣어 출력
        # print(regu[a][b % 4] if b % 4 != 0 else regu[a][0])
        if b % 4 == 0:
            print(regu[a][3])
        else:
            print(a**b[-1])

# 이렇게 하면 2 4를 넣었을 때 6이 나와야 하는데 8이 나옴. a>b일 때를 고려해서 다시 풀자..
